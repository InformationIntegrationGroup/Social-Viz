<html>
<head>

<link rel="stylesheet" href="style.css">

<script type="text/javascript" src="d3.v3.min.js">
</script>

</head>


<body>

<div id="tooltip" class="hidden">
  <p><strong>Properties</strong></p>
  <p>Id: <span id="term1"></span></p>
  <p>Index: <span id="term2"></span></p>
  <p>Correct: <span id="term3"></span></p>
  <p>Weight: <span id="term4"></span></p>
  <p>Label: <span id="term5"></span></p>
</div>

<script type="text/javascript" src="barChart.js">
</script>
<script type="text/javascript" src="areaChart.js">
</script>
<script type="text/javascript">
var padding = 20;
var width=window.innerWidth - padding;           //width and height of scope
var height=window.innerHeight - padding;
 
var maxNodeWeightSet=new Array();              //maxNodeWeight is the largest value of json file
var maxEdgeWeightSet = new Array();            //the larget weight of edge of json file
var maxIndex=836;                              //maxIndex is fixed
var maxNumberOfNodes=300;                      //max number of nodes can be displayed on the screen

var K=4;                                       //number of clusters
var size=20;                                   //number of reading json files
var transitionTime=3000;                        //the time for transition process
var count=0;                                   //count the number of transition execute
var nodesSet=new Array();                      //store all nodes read from json file 
var edgesSet=new Array();                      //store all edges read from json file
var prePosition=new Array();                   //the node's position of previous frame,used to avoid freak move of nodes when load new data
var nodeRadius=8;                                  //the raduis of nodes
var clustersSet;                               //store cluster info by sequence
var clusterMap={};                             //used to check if one node is cluster
var fileDateSet=new Array();                   //the date of file
var countGroupSet=new Array();                 //number of nodes for each group of each json file
var tmpCountGroup=new Array();
var highlightEdge=new Array();                 //highlight array is used when one node is hovered 
var displayThreshold=0                         //whether or not display the nodes in normal size
var nonDisplayDistance=60;                    //the distance for nodes that are not displayed to their cluster
var tmpNodes=new Array();                      //tmpNodes store all nodes info for current file
var preNodesMap = new Array();                 //The map of previous node, the key is node's id
var nodesMap = new Array();                   //nodes map for current nodes set
var nodeTraceMap = new Array();                //the trace map indicates how many times the node on its right cluster during the whole process.
var traceMapCounter = new Array();             //traceMapCounter is used to count number of values in node trace map
var clusterNodesHistory = new Array();         //history of how many nodes in the manner of different colors in the cluster for each file
var showStackChart = -1;                       //whether the stack chart is shown, and the chart for which cluster
var areaChartData = new Array();               //x, y position for chart, x is fraction of correct nodes in clusters and y is date
var hashtags = new Array();                    //hashtags of all nodes
var matchTrace = new Array();                  //matching items' id
var maxMatchingItems = 10;                     //max number of showing matching items
var highlightSearchNode = new Array();         //nodes that are chosen from matching items
var inputStrLength = "";                       //the length of string in the search box
var nodeHistory = new Array();                 //history of nodes that which cluster the node in

var rScale=d3.scale.linear()                   //return the radius of node
    .range([0,10]);

var cScale = d3.scale.category20();            //return color of node

var linkColorScale = d3.scale.linear()         //return color of edge
    .range([0, 1]);

var plusScale = d3.scale.ordinal();             //plusScale is used to compute the distance from nodes to cetner of cluster circle

var nonGroupPos = {x: width-100, y: height/2};  //the group center for non-group nodes

var colorData = d3.range(K).map(function(d, i){  //the RGB of colors will be used to paint
    return d3.rgb(cScale(i + 1));
})

svg=d3.select("body")                         //create svg
    .append("svg")
    .attr("width",width)
    .attr("height",height)

link = svg.selectAll(".link");                //array of all edges
node = svg.selectAll(".node");                //array of all nodes
cluster = svg.selectAll(".cluster");          //array of all clusters
date = svg.append("text")                     //show date of scene
    .attr("class", "date")
    .attr("x", 150)
    .attr("y", 20)
    .attr("fill", "white");
stackChart = svg.append("g")                 //stackChart is place to draw stack chart, the position is decided by the cluster's position
    .attr("id", "stackChart");
layer = stackChart.selectAll(".layer")        //layer of stack layout
rect = layer.selectAll("rect")                //rect in stack layout
chart = svg.append("g");                      //chart is space to draw line and area chart                      

userBar = svg.append("g");                    //user bar continuous moves down when chart is drawn
cover = userBar.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", 60)
    .attr("width", chartWidth * (K + 2))
    .attr("fill", "black");
cover.transition()
    .duration(3000 * 20)
    .ease("linear")
    .delay(3500)
    .attr("y", chartHeight);

searchArea = svg.append("g");                 //item are matching items set
var item = searchArea.selectAll(".matchItemText");

searchButton = userBar.append("circle")      //search button is kind of configuration button, click on it, the search box will be shown
    .attr("fill", d3.rgb(0, 0, 150))
    .attr("r", 5)
    .attr("cx", 10)
    .attr("cy", height - 20)
    .attr("id", "searchButton")
    .datum(function(){
        var d = {};
        d.show = false;
        return d;
    })
    .on("click", function(d){
        if (!d.show){
            d3.select(this)
                .transition()
                .duration(500)
                .attr("r", 4)
                .attr("stroke", "steelblue")
                .attr("stroke-width", 2);
            d3.select("#inputText")
                .classed("hidden", false);
            d.show = true;
        } else {
            d3.select(this)
                .transition()
                .duration(500)
                .attr("stroke-width", 0)
                .attr("r", 5);
            d3.select("#inputText")
                .classed("hidden", true);
            document.getElementById("inputText").value = "";
            d.show = false;
            resetSearchBox();               
        }
    })     

htmlArea= userBar.append("foreignObject")
    .attr("x", 15)
    .attr("y", height - 30)
    .attr("height", 20)
    .attr("width", chartWidth * 4);  //insert html component into svg
htmlBody = htmlArea.append("xhtml:body")
    .style("margin",0)
    .style("padding",0);
inputText = htmlBody.append("input")
    .attr("id", "inputText")
    .classed("hidden", true)
    .attr("type", "text")
    .attr("placeholder", "hashtag")
    .attr("onkeyup", "matchHashtag()");       //introduce search box

var yAxis = d3.svg.axis()
    .scale(axisYScale)
    .ticks(size)
    .orient("left");                   //yaxis for chart

var axisG = chart.append("g")                 //svg:g for y axis component
    .attr("class", "y axis")
    .attr("transform", "translate(10, 0)"); 
var avgSlot = chartHeight / size;             //distance between axis ticks
axisData = d3.range(size).map(function(d){
    return (chartYScale(d) + avgSlot / 2).toPrecision(K);
})
axisData.forEach(function(d, i){
    axisG.append("rect")
        .attr("fill", "transparent")
        .attr("height", avgSlot)
        .attr("width", 10)
        .attr("transform", "translate(-10," + d +")")
        .datum(function(){
            var tmpD = {};
            tmpD.index = i;
            tmpD.val = d;
            return tmpD;
        })
        .on("mouseover", function(e){
            var obj = d3.select(this)
                .attr("fill", "steelblue");
            for (var i = 0; i < K; i++){
                var tmpD = areaChartData[i][e.index + 1];
                appendHorizontalComponent(tmpD, i);
            }
            chart.append("text")
                .attr("class", "chosenDate")
                .attr("x", chartWidth * 5)
                .attr("y", parseInt(e.val) + avgSlot / 2)
                .attr("fill", " white")
                .attr("font-size", 10)
                .text("March " + (e.index + 1))
                .attr("opacity", 0)
                .transition()
                .duration(500)
                .attr("opacity", 1);
        })
        .on("mouseout", function(e){
            d3.select(this)
                .attr("fill", "transparent");
            chart.selectAll(".lineChartCircleH")
                .transition()
                .duration(500)
                .attr("r", 0)
                .remove();
            chart.selectAll(".lineChartTextH")
                .transition()
                .duration(500)
                .attr("opacity", 0)
                .remove();
            chart.selectAll(".chosenDate")
                .transition()
                .duration(500)
                .attr("opacity", 0)
                .remove();
        });
})
axisG.call(yAxis);
 
var pieRadius = 30;                          //the raduis of pie chart
var pie = d3.layout.pie()                    //pie layout
    .sort(null)
    .value(function(d){
        return 1;
    });
var arc = d3.svg.arc()
    .outerRadius(pieRadius)
    .innerRadius(pieRadius * 0.8);
var pieChart = svg.append("g")

var grads = svg.append("defs")
    .selectAll("radialGradient")
    .data(colorData)
    .enter()
    .append("radialGradient")
    .attr("id", function(d, i){
        return "grad" + (i + 1);
    })
    .attr("cx", "50%")
    .attr("cy", "50%")
    .attr("r", "70%");              //Radial gradients use to fill nodes, give a feeling of comet
grads.append("stop")
    .attr("offset", "0%")
    .style("stop-color", function(d){
        //var color = d3.rgb(cScale(d.color));
        return "rgb(" + d.r + "," + d.g + "," + d.b + ")";
    })
    .attr("stop-opacity", 1);
grads.append("stop")
    .attr("offset", "20%")
    .style("stop-color", function(d){
        return "rgb(" + Math.floor(d.r / 2) + "," + Math.floor(d.g / 2) + "," + Math.floor(d.b / 2) + ")";
    })
    .attr("stop-opacity", 0.7);
grads.append("stop")
    .attr("offset", "100%")
    .style("stop-color", function(d){
        return "rgb(0, 0, 0)";
    })
    .attr("stop-opacity", 0);

var force = d3.layout.force()                 //create force layout
    .charge(function(d){
        if (d.display < displayThreshold){
            return -2;
        } else {
            return -7;
        }
    })                                        //charge>0 nodes attract, charge<0 nodes repel, value is the threshold of apply the force
    .linkDistance(function(d){                //generally the distance between two nodes who are linked by edge
        //return (d.source.group==d.target.group)?10:20;
        return 50;                            //no group option, the link distance is same 
    })
    .friction(0.9)                            //[0,1] default 0.9, velocity decay after tick
    .linkStrength(0)                          //[0,1]  default 1
    .gravity(0)                            //the force to drag nodes to the enter
    .size([width, height])
    .on("tick",tick);

var forceCluster= d3.layout.force()           //the force-layout for clusters
    .size([width, height])
    .gravity(0.01)
    .friction(0.7)
    .charge(-1500)
    .on("tick",tickCluster);

loadHashtags();
loadFile();
getCluster();
setCluster();
setTimeout(transit,1000);                     //start to transition


function tick(e) {
    var k = .1 * e.alpha;                       // Push nodes toward their designated focus. 
    tmpNodes.forEach(function(o, i) {      
        var diffX = (o.group <= K) ? clustersSet[o.group - 1].x - o.x : nonGroupPos.x - o.x;
        var diffY = (o.group <= K) ? clustersSet[o.group - 1].y - o.y : nonGroupPos.y - o.y;
        var distance = Math.sqrt(diffX * diffX + diffY * diffY);
        
        if (distance > o.plus.ed){
            o.y += (diffY) * k;
            o.x += (diffX) * k;
        }
        if (distance < o.plus.st){
            tmpK = k;
            if (o.radius < displayThreshold){
               tmpK = 2 * k;
            } 
            o.y -= (diffY) * tmpK;
            o.x -= (diffX) * tmpK;                    
        }
        if (o.text){                              //if nodes have label with it, label moves with the node
            o.text
                .attr("x",o.x + 5)
                .attr("y",o.y);
        }

    });

    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("cx", function(d) { return d.x = Math.max(d.radius, Math.min(width - d.radius, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(d.radius, Math.min(height - d.radius, d.y)); });
}   

function tickCluster(e){
    cluster.attr("cx", function(d) { return d.x = Math.max(d.radius, Math.min(width - d.radius, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(d.radius, Math.min(height - d.radius, d.y)); });
}

function loadFile(){
    var xmlhttp=new XMLHttpRequest();                  //AJAX, read file synchronous
    for(i=0;i<size;i++){
        var url="formattedCumulative/"+i+".json";
        xmlhttp.open("GET",url,false);
        xmlhttp.send(null);
        var tmpJson=eval('(' + xmlhttp.responseText + ')');
        var nodes=new Array();
        var edges=new Array();
        var fileDate="";
        var maxNodeWeight=tmpJson.maxNodeWeight;
        var maxEdgeWeight = tmpJson.maxEdgeWeight; 
        var countGroup=tmpJson.countGroup;
        nodes=tmpJson.nodes;
        edges=tmpJson.edges;  
        fileDate=tmpJson.date;
        nodesSet.push(nodes);                       //store reading data into array
        edgesSet.push(edges);
        fileDateSet.push(fileDate);
        maxNodeWeightSet.push(maxNodeWeight);
        maxEdgeWeightSet.push(maxEdgeWeight);
        countGroupSet.push(countGroup);
    }
}

function transit(){
    getPrePosition();                             //get the previous node's position 
    tmpNodes=nodesSet[count];
    tmpEdges=edgesSet[count];  
    tmpCountGroup=countGroupSet[count];
    var tmpFileDate=fileDateSet[count];
    var maxNodeWeight = maxNodeWeightSet[count];
    var maxEdgeWeight = maxEdgeWeightSet[count];
    rScale.domain([0,Math.log(maxNodeWeight)]);
    linkColorScale.domain([0,Math.floor(Math.log(maxEdgeWeight))]);
    date.text(tmpFileDate);                       //set the date of scene
    for(var i=0;i<tmpNodes.length;i++){
        var index=tmpNodes[i].id;
        if(prePosition[index]){
            tmpNodes[i].x=prePosition[index].x;   //if the node is exist in the previous frame, get their coordinate
            tmpNodes[i].y=prePosition[index].y;   //this will avoid freak move of nodes
        }  
    }

    axisYScale.domain([0, count + 1])                 //update y Axis
        .range([0, chartHeight / 20 * (count + 1)]);      
    yAxis.scale(axisYScale)
        .ticks(count + 1);
    axisG.call(yAxis);

    //alert(Math.floor(Math.sqrt(maxEdgeWeight)));
    updateCluster(count);  
    setNode(count);  
    setParameters(count);
    drawAreaChart(areaChartData);                  //draw area chart

    force.nodes(tmpNodes)                        //start force layout
        .links(highlightEdge)
        .start(); 

    count++;                                     //if more json files are available
    if(count<size)
        setTimeout(transit, transitionTime);               //go to next transition. 
}

function setLink(){
  link=link.data(highlightEdge,function(d,i){        //give new loading data to edges
      return d.source.id+"-"+d.target.id;
  });

  link.enter()                                  //for new added edges, assign attribute
      .append("line")
      .attr("class", "link")
      .attr("stroke", function(d){
          var fraction = linkColorScale(Math.ceil(Math.log(d.value)));
          return d3.hsl((fraction * 360) ,1 , 0.5);
      })
      .each(function(d){
          d3.select(this)
              .moveToBack();
      });
   
  link.exit()                                   //remove edges are not appear in json file
      .transition() 
      .duration(200)
      .attr("stroke-opacity", 0)
      .remove();
}

function setNode(num){
    //rScale less then displayThreshold will have 0 radius
    displayThreshold=10-maxNumberOfNodes/tmpNodes.length*10;
    var shownSeachedNodes = [];                        //searched nodes is shown on the screen

    node = node.data(tmpNodes,function(d){             //give new loading data to nodes
        return d.id;    
    });

    node.enter()                                       //for new added node assign attributes
        .append("circle")
        .attr("class", "node")
        .attr("fill", function(d){
            return "url(#grad" + d.color + ")";
        })
        .attr("r", function(d){
            return 1;
        })
        .on("mouseover",mouseoverFunc)
        .on("mouseout",mouseoutFunc)
        .call(force.drag);

    node.transition()                              //set transition process, the radius of node from 0 to 5 
        .duration(500)
        .attr("r", function(d){  
            var r = rScale(Math.log(d.weightN));      //compute the radius of node
            d.display = r;
            if (d.display >= displayThreshold){
                d.radius = nodeRadius;
            } else {
                d.radius = nodeRadius / 4;
            }  
            if (d.id in highlightSearchNode){
                shownSeachedNodes[d.id] = 1;
                d.highlighted = true;
                d.text = highlightSearchNode[d.id];
                d.text
                    .attr("opacity", 1);
                /*d3.select(this)
                    .classed("highlightedNode", true);*/
                return nodeRadius * 2;
            }
            return d.radius;
        });

    node.exit()                                           //remove nodes no longer in the json file
        .transition()
        .duration(500)
        .attr("opacity", 0)
        .remove();
    highlightSearchNode.forEach(function(d){
        var index = d.datum();
        if (index in shownSeachedNodes){
            
        } else {
            d.attr("opacity", 0);            
            //console.log(d.datum());
        }
    })
}

function setParameters(num){
    svg.selectAll(".moveText")                    //remove labels created for moving bigger nodes
        .transition()
        .duration(200)
        .attr("opacity", 0)
        .remove();
    svg.selectAll(".comet")                       //set the radius of highlighted node to normal size
        .classed("comet", false)
        //.transition()
        //.duration(500)
        .attr("r", function(d){
            return d.radius;
        });

    nodesMap = [];

    for (var i = 0; i < clustersSet.length; i++){
        traceMapCounter[i] = Array.apply(null, new Array(size + 1)).map(Number.prototype.valueOf, 0);
    }

    node.each(function(d){
        if (d.id in clusterMap){                  //check if node is cluster
            d3.select(this).classed("clusterNode",true);
        }

        nodesMap[d.id] = d;                       //set node's info into node map
        if (d.group == d.color){
            if (nodeTraceMap[d.id]){              //set the number of times the node on its right cluster
                nodeTraceMap[d.id]++;      
            } else {
                nodeTraceMap[d.id] = 1;
            }
        } 
        //traceMapCounter record the number of correct times in different clusters
        if (d.group == d.color && d.display >= displayThreshold){
            traceMapCounter[d.group - 1][nodeTraceMap[d.id]]++;
            traceMapCounter[d.group - 1][0] ++;      //[d.group - 1][0] is used to count the sum of values from [1] to [size] 
        }
        //d.group indicates which group the node in now, num means the data for which day
        //and d.color means the node's final group
        if (d.group <= K){
            clusterNodesHistory[d.group - 1][num][d.color - 1]++;  
        }     

        //if node is not in the nodeHistory, create an array with size of given size, and all elements are -1, which means it does not exist in any cluster.
        if (!(d.id in nodeHistory)){
            nodeHistory[d.id] = Array.apply(null, new Array(size)).map(Number.prototype.valueOf, -1);
        }
        nodeHistory[d.id][num] = d.group;
    });

    plusMap = new Array();                          //compute the range for each value, such as value = 8, range [50, 60]
    for (var i = 0; i < clustersSet.length; i++){
        plusMap.push(new Array());
        var clusterRadius = cluster[0][i].__data__.radius;
        var diff = (clusterRadius - 50) / (num + 1);
        var pre = 20;
        var sum = 0;
        for(var j = num + 1; j > 0; j--){
            if (traceMapCounter[i][j] != 0){  
                var fraction = traceMapCounter[i][j] / traceMapCounter[i][0];  
                var section = Math.floor(fraction * (num + 1)); 
                if (section == 0){                    
                    if (sum >= 10){
                        section = 1;
                    } else {
                        plusMap[i][j] = {st: pre, ed: diff + pre}; 
                        sum++;
                        continue;
                    }
                }
                plusMap[i][j] = {st: pre, ed: diff * section + pre};
                pre += diff * section;
                sum = 0;
            }
        }
    }
    
    node.each(function(d){                         //for nodes will travel between cluster, append the label to the node
        if(preNodesMap[d.id] && preNodesMap[d.id].group != d.group && !d.highlighted){
            var obj = svg.append("text")           
                .classed("moveText", true)         
                .attr("fill", "white")
                .text(d.label)
                .attr("x", d.x + 5)
                .attr("y", d.y);
            d.text = obj;
            //obj.moveToBack();
            d3.select(this)                        //highlight node
                .attr("class", "comet")
                .transition()
                .duration(500)
                .attr("r", nodeRadius * 2);
        }

        
        var plus = {st : 0, ed : 0};              //plus is the computed distance from node to center of cluster, [st, ed] is range
        if (d.group > K){
            d.plus = plus;
            return;
        }
        var r = cluster[0][d.group - 1].__data__.radius;
        if (d.display < displayThreshold){         //for nodes with smaller radius, they will appear at the very edge of cluster circle
            plus.ed = r;
            plus.st = plus.ed * 0.9;
        } else if (d.id in clusterMap){           //for nodes which are cluster, should be located at the center of cluster circle
            plus.st = 0;
            plus.ed = 2;
        } else {                                  //other nodes' distance to center is based on the correct times of color and group
            if (d.group == d.color){
               plus = plusMap[d.group - 1][nodeTraceMap[d.id]];
            } else {
                plus.ed = r - 10;
                plus.st = plus.ed * 0.9;
            }
        }
        //console.log(d.id + " " + nodeTraceMap[d.id] + " " + plus);
        d.plus = plus;

    }); 

    preNodesMap = nodesMap; 

    for (var i = 0; i < K; i++){                   //set today's value to areaChartData
        var fraction = clusterNodesHistory[i][num][i] / d3.sum(clusterNodesHistory[i][num]);
        areaChartData[i].push({
            fraction : i + fraction,
            index : num + 1,
        });
    }   

    if (showStackChart != -1){                     //draw bar chart
        /*var d = cluster[0][showStackChart].__data__;
        var xpos = d.x - d.radius - size * 5;
        var ypos = d.y - d.radius * 1.414 / 2;
        drawNodesHistory(showStackChart, xpos, ypos);*/
        drawNodesHistory(showStackChart);
    }    
}

function getPrePosition(){                             //get the position of nodes in the previous frame
    prePosition=[];
    for(var i=0;i<node[0].length;i++){
        var index=node[0][i].__data__.id;
        var xpos=node[0][i].__data__.x;
        var ypos=node[0][i].__data__.y;
        prePosition[index]={
            x:xpos,
            y:ypos,
        };
    }
}

function getCluster(){
    var xmlhttp=new XMLHttpRequest();         //AJAX, read cluster file
    var url="formattedCumulative/cluster.json";
    xmlhttp.open("GET",url,false);
    xmlhttp.send(null);
    tmpJson=eval('(' + xmlhttp.responseText + ')');
    var tmpClusters=tmpJson.clusters;
    clustersSet=tmpClusters;
    for(var i=0;i<tmpClusters.length;i++){
        clusterMap[tmpClusters[i].id]=tmpClusters[i];      //set the cluster info in the map, the key is node's id
        clusterNodesHistory.push(new Array());             //initialize clusterNodesHistory
    }
}

function setCluster(){                                 //set the cluster force-layout
    cluster=cluster.data(clustersSet);
    cluster.enter()
        .append("circle")
        .attr("class","cluster")
        .attr("fill", "transparent")
        .attr("stroke", function(d, i){
            return cScale(d.group);
        })
        .attr("stroke-width", 1)   
        .attr("stroke-opacity", 0.8)
        .on("mouseover", function(d){
            var obj = d3.select(this) 
                //.transition()
                //.duration(500)
                .attr("stroke-opacity", 1)
                .attr("stroke-width", 2);
            var xpos = d.x - d.radius - size * 5;
            var ypos = d.y - d.radius * 1.414 / 2;
             //drawNodesHistory(d.group, xpos, ypos);
        }) 
        .on("mouseout", function(d){
            var obj = d3.select(this)
                //.transition()
                //.duration(500)
                .attr("stroke-opacity", 0.8)
                .attr("stroke-width", 1);
            //removeNodesHistory();
        })
        .on("click", function(d){
            if (showStackChart == d.group){
                drawNodesHistory(-1);
            } else {
                drawNodesHistory(d.group);
            }
        })
        .call(forceCluster.drag);

    //initialize parameters
    for (var i = 0; i < clustersSet.length; i++){                
        traceMapCounter.push(new Array());
        traceMapCounter[i] = Array.apply(null, new Array(size)).map(Number.prototype.valueOf, 0);
        areaChartData.push([{
            fraction : i,
            index : 0,
        }]);
    }
}

function updateCluster(num){    
    cluster.transition()     
        .duration(1000)   
        .attr("r",function(d){                        //this line compute the radius of cluster
            var r=Math.ceil(Math.sqrt(tmpCountGroup[d.group-1])*12);
            d.radius=Math.max(r,nonDisplayDistance);
            return d.radius;
        });
        
    forceCluster.nodes(clustersSet)
        .start();

    for (var i = 0; i < K; i++){
        clusterNodesHistory[i].push(new Array());
        for (var j = 0; j < K; j++){
            clusterNodesHistory[i][num].push(0);
        }
    }
}

function mouseoverFunc(d){
    d3.select("#tooltip")               //set the tool tip of nodes    
        .style("left", 0 + "px")              
        .style("top",40 + "px");         
    d3.select("#term1")
        .text(d.id);
    d3.select("#term2")
        .text(d.indexN);
    d3.select("#term3")
        .text(nodeTraceMap[d.id]);
    d3.select("#term4")
        .text(Math.ceil(d.weightN));
    d3.select("#term5")
        .text(d.label);
    d3.select("#tooltip")
        .classed("hidden", false);

    svg.selectAll(".moveText")             //remove labels created for moving bigger nodes
        .transition()
        .duration(200)
        .attr("opacity", 0)
        .remove();

    /*svg.selectAll(".comet")
        .classed("comet", false)
        .transition()
        .duration(500)
        .attr("r", function(d){
            return d.radius;
        });*/

          
    var highMap=new Array();            //highlight the node, its edges and its neighbors
    highMap[d.index]=true;
    for(var i=0;i<tmpEdges.length;i++){
        var tmp=tmpEdges[i];
        var src,tar;
        if(tmp.source.indexN)
            src=tmp.source.indexN;
        else 
            src=tmp.source;
        if(tmp.target.indexN)
            tar=tmp.target.indexN;
        else
            tar=tmp.target;
        if(src==d.index){                  
            highMap[tar]=true;
            highlightEdge.push(tmp);
        }
        if(tar==d.index){                  
            highMap[src]=true;
            highlightEdge.push(tmp);
        }              
    }

    //console.log(d.indexN);
        
    force.links(highlightEdge)
        .start();
    setLink();

    node.each(function(o){
        if(o.index in highMap && !o.highlighted){
            var obj = svg.append("text")
                .classed("linkText",true)
                .attr("fill", "white")
                .text(o.label)
                .attr("x",o.x+5)
                .attr("y",o.y);
            obj.moveToBack();
            return;
        }
        d3.select(this).classed("inactive",true);                
    });

    var pos = d3.mouse(this);
    var tmpData = nodeHistory[d.id];
    var path = pieChart.attr("transform", "translate(" + pos[0] + "," + pos[1] + ")")
        .selectAll(".pieChart") 
        .data(pie(tmpData))
        .enter()
        .append("path")
        .attr("class", "pieChart")
        .attr("fill", function(d){
            if (d.data == -1 || d.data > K){
                return "black";
            }
            return cScale(d.data);
        })
        .attr("d", arc)
        .each(function(){
            this._current = {
                startAngle : 0,
                endAngle : 0
            }
        })
        .transition()
        .duration(1000)
        .attrTween('d', function(d){
            var interpolate = d3.interpolate(this._current, d);
            this._current = interpolate(0);
            return function(t){
                return arc(interpolate(t));
            }
        })
    pieChart.moveToFront();
}

function mouseoutFunc(d){                              //remove highlighted components
    d3.select("#tooltip")
        .classed("hidden",true);
    highlightEdge=new Array();
    force.links(highlightEdge)
        .start();
    setLink();

    d3.selectAll(".node.inactive")
        .classed("inactive",false);
    d3.selectAll(".linkText")
        .remove();
    d3.selectAll(".pieChart")
        .transition()
        .duration(500)
        .attr("opacity", 0)
        .remove();
}

function drawNodesHistory(index){
    showStackChart = index; 
    if (index == -1){
        removeNodesHistory();
        return;
    }   
    
    //console.log(xpos + " " + ypos);
    drawBarChart(index - 1, clusterNodesHistory[index - 1]);
}

function removeNodesHistory(){
    rect.transition()
        .duration(200)
        .attr("opacity", 0)
        .remove();
    layer.remove();
}

function matchHashtag(){                               //compute the matching items and show them on the screen
    var obj = document.getElementById("inputText");
    var val = obj.value;
    if (val.length > inputStrLength){                  //when letter taped, recompute the matching items
        inputStrLength = val.length;
        var last = matchTrace[matchTrace.length - 1];
        var matched = [];
        var matchedMid = [];
        last.forEach(function(d){
            var str = hashtags[d];
            if (str.substring(0, val.length).toLowerCase() == val.toLowerCase()){
                matched.push(d);
            } else if (str.indexOf(val) != -1){
                matchedMid.push(d);
            }
        });
        matchTrace.push(matched.concat(matchedMid));
    } else {                                          //when letters deleted, recompute the matching items
        var diff = inputStrLength - val.length;
        for (var i = 0; i < diff; i++){
            matchTrace.pop();
        }
        inputStrLength = val.length;
    }

    if (matchTrace.length == 1){                      //when no letter in the search box, no item should be shown
        item = item.data([]);
        item.exit()
            .remove();
    } else {
        var last = matchTrace[matchTrace.length - 1];
        var tmpData = last.slice(0, Math.min(maxMatchingItems, last.length));
        item = searchArea.selectAll(".matchItemText").data(tmpData);
        item.enter()                                  //append top max matching items text on the screen
            .append("text")
            .attr("class", "matchItemText")
            .attr("x", 20 + chartWidth * 4)
            .attr("y", function(d, i){
                return height - i * 20 - 15;
            })
            .attr("fill", "white")
            .text(function(d){
                return hashtags[d];
            })
            .on("mouseover", function(d, i){
                var obj = searchArea.append("rect")
                    .attr("x", 20 + chartWidth * 4)
                    .attr("y", height - i * 20 - 30)
                    .attr("width", 0)
                    .attr("height", 20)
                    .attr("fill", "steelblue");
                obj.moveToBack();
                obj.transition()
                    .duration(500)
                    .attr("width", 80);
            })
            .on("mouseout", function(){
                searchArea.selectAll("rect")
                    .transition()
                    .duration(500)
                    .attr("opacity", 0)
                    .remove();
            })
            .on("click", function(d){   
                node.each(function(e){
                    if (e.id == d){
                        var obj = svg.append("text")
                            .attr("class", "highlightedText")
                            .text(e.label)
                            .attr("x", e.x + 5)
                            .attr("y", e.y)
                            .datum(d);
                        obj.moveToBack();
                        e.text = obj;
                        highlightSearchNode[d] = obj;
                        d3.select(this)
                            .classed("highlightedNode", true)
                            .attr("r", nodeRadius * 2);
                    }
                })

                resetSearchBox();
                console.log(hashtags[d]);
            });
        item.text(function(d){
            return hashtags[d];
        });
        item.exit()
            .remove();
    }
}

function resetSearchBox(){                             //reset parameters of search box 
    document.getElementById("inputText").value = "";
    matchTrace = matchTrace.slice(0, 1);
    inputStrLength = 0;
    searchArea.selectAll("rect")
        .transition()
        .duration(500)
        .attr("opacity", 0)
        .remove();
    searchArea.selectAll("text")
        .remove();
}

function loadHashtags(){
    d3.csv("hashtags.csv", function(data){
        data.forEach(function(d){
            hashtags.push(d.tag);
        });
        var tmp = d3.range(hashtags.length).map(function(d){
            return d;
        });
    matchTrace.push(tmp);
});
}

d3.selection.prototype.moveToBack = function() { 
    return this.each(function() { 
        var firstChild = this.parentNode.firstChild; 
        if (firstChild) { 
            this.parentNode.insertBefore(this, firstChild); 
        } 
    });    //move component to the down of svg
};

d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });   //move component to the up of svg
};

d3.timer(function(){
    d3.selectAll(".comet, .highlightedNode")
        .each(function(d){
            if (!d.preX){
                d.preX = d.x;
                d.preY = d.y;
            }
            svg.append("line")
                .attr("stroke-width", 2)
                .attr("stroke", cScale(d.color))
                .attr("stroke-opacity", 1)
                .attr("x1", d.preX)
                .attr("y1", d.preY)
                .attr("x2", d.x)
                .attr("y2", function(){
                    d.preX = d.x;
                    d.preY = d.y;
                    return d.y;
                })
                .transition()
                .duration(700)
                .attr("stroke-width", 0)
                .remove();
        })
}, 300);

</script>
</body>
</html>